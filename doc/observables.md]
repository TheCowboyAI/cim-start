# Observables
Using observables with Iced UI is a great idea if you want to build reactive pipelines and avoid the more limited iterator-based event handling when dealing with asynchronous sources like NATS and other event streams. Iced’s design—heavily inspired by The Elm Architecture—relies on a message-based system where updates are dispatched from asynchronous tasks (subscriptions) into your UI update function[1][4]. Converting your NATS events and event streams into an observable pattern lets you leverage operators like map, filter, and debounce, enabling more expressive event handling.

## Bridging Observables and Iced UI

-  **Iced’s Subscription Model**  
Iced allows you to define subscriptions that convert asynchronous data sources (such as a stream from a NATS client) into messages that update your UI. Although Iced does not offer a built-in “observable” abstraction, you can create a custom subscription that wraps an observable-like stream. This subscription would take your NATS asynchronous stream—using libraries like `async_nats` or even wrapping it using an Rx-style library such as RxRust—and then transform each event into an Iced message[4][2].

-  **Converting From Iterators to Observables**  
While iterators and simple asynchronous streams are sufficient for many use cases, using an observable pattern provides additional capabilities. Observables let you compose and transform streams of events using various operators, which can be especially useful when dealing with intermittent network messages or when you need to process events concurrently[6][3]. You can design an adapter that listens for NATS events (via tokio’s async stream or similar) and “observes” them. Then, using combinators, you can convert this into a stream that feeds into an Iced subscription, effectively treating each event as an observable event.

-  **Implementing the Bridge**  
One approach is to create a custom Iced subscription. In this subscription, you would:  
- Initialize your NATS client (using, for example, `async_nats`).  
- Subscribe to the relevant subjects and obtain an asynchronous stream of messages.  
- Wrap this stream so that it provides observable semantics (for example, by integrating with an Rx-like library or by using futures stream combinators to simulate the behavior of observables).  
- Map each event to an Iced message and yield it to the Iced runtime, ensuring that messages are dispatched as soon as new events are received.

Below is a simplified pseudocode example that outlines this idea:

```rust
#[derive(Debug, Clone)]
enum Message {
    NatsEvent(String),
}

fn nats_events_subscription() -> iced::Subscription {
    iced::Subscription::from_recipe(NatsEventsSubscription)
}

struct NatsEventsSubscription;

impl iced::subscription::Recipe for NatsEventsSubscription
where
    H: std::hash::Hasher,
{
    type Output = Message;

    fn hash(&self, state: &mut H) {
        // Ensure this subscription is uniquely identified.
        "NatsEventsSubscription".hash(state);
    }

    fn stream(self: Box, _input: I) -> futures::stream::BoxStream {
        // Here, you would connect to your NATS server and wrap the
        // resulting async stream with your observable-style combinators.
        // Then, map each event to a Message::NatsEvent
        async_stream::stream! {
            // Pseudo-code: connect, subscribe, and transform:
            // let mut nats_stream = connect_and_subscribe_to_nats();
            // while let Some(event) = nats_stream.next().await {
            //     let message_text = process_event_with_observable_ops(event);
            //     yield Message::NatsEvent(message_text);
            // }
        }
        .boxed()
    }
}
```

This example outlines the concept: by wrapping your asynchronous event source into a custom subscription, you convert observable events into Iced messages that update your UI. The design favors reactivity and composability, allowing you to leverage the more powerful abstraction of observables while still integrating into Iced’s message-based update system[1][8].

## Final Thoughts

To sum up, while Iced UI is built around a message/update cycle that traditionally consumes asynchronous streams or iterators, you can certainly integrate observables by creating appropriate adapters. This approach lets you take advantage of observables’ powerful operators to manage, transform, and compose NATS events or other event streams before dispatching them as UI messages. This pattern combines the strengths of both reactive programming and Iced’s declarative architecture, allowing for more expressive and scalable event handling in your application.

This summary demonstrates how observables can replace traditional iterators through a custom subscription and adapter layer, ultimately bridging NATS, event streams, and Iced UI effectively.

Citations:
[1] https://github.com/iced-rs/iced
[2] https://natsbyexample.com/examples/messaging/pub-sub/rust
[3] https://users.rust-lang.org/t/observer-patterns-in-rust/86481
[4] https://docs.rs/iced/latest/iced/
[5] https://natsbyexample.com/examples/kv/intro/rust
[6] https://stackoverflow.com/questions/39439653/events-vs-streams-vs-observables-vs-async-iterators
[7] https://www.youtube.com/watch?v=UK891y93PdY
[8] https://docs.rs/relm/latest/relm/struct.EventStream.html
[9] https://users.rust-lang.org/t/rants-an-async-nats-client-library/32862
[10] https://blog.logrocket.com/composing-underpinnings-observable-rust-application/
[11] https://stackoverflow.com/questions/36968402/what-is-the-use-case-for-cold-observables
[12] https://news.ycombinator.com/item?id=28326125
[13] https://discourse.iced.rs/t/the-simplest-example-possible/191
[14] https://www.reddit.com/r/learnrust/comments/mc83am/iced_gui_tutorial_or_guidelines_needed/
[15] https://iced.rs
[16] https://github.com/iced-rs/awesome-iced
[17] https://discourse.iced.rs/t/my-first-month-with-iced/446
[18] https://users.rust-lang.org/t/egui-vs-iced-in-regards-to-game-engine-integration/74569
[19] https://github.com/nats-io/nats.rs
[20] https://www.qovery.com/blog/a-guided-tour-of-streams-in-rust/
[21] https://github.com/nats-io/nats.rs/issues/1283
[22] https://github.com/rxRust/rxRust
[23] https://docs.rs/nats
[24] https://docs.rs/rxr
[25] https://stackoverflow.com/questions/56549704/nestjs-nats-request-response
[26] https://blog.enapi.com/building-event-streams-with-rust-and-kafka-a-practical-guide-905178817c76
[27] https://docs.rs/nats/latest/nats/struct.Options.html
[28] https://github.com/whatwg/dom/issues/544
[29] https://stackoverflow.com/questions/73342204/rust-missingormalformedextensions-while-connecting-to-nats
[30] https://reactivex.io
[31] https://krshrimali.github.io/posts/2022/12/i-started-building-an-app-using-rust-and-here-is-how-it-went.../
[32] https://github.com/iced-rs/iced/blob/master/examples/README.md
[33] https://www.brochweb.com/blog/post/writing-a-native-gui-app-in-rust-with-iced/
[34] https://stackoverflow.com/questions/32190445/hot-and-cold-observables-are-there-hot-and-cold-operators
[35] https://stackoverflow.com/questions/2521277/what-are-the-hot-and-cold-observables