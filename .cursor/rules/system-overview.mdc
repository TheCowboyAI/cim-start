---
description: High-level overview of the Adaptive Memory Bank System
globs: 
alwaysApply: false
---
# ADAPTIVE MEMORY BANK SYSTEM OVERVIEW

> **TL;DR:** This system uses structured documentation as AI memory across sessions. It offers four complexity levels that scale from quick bug fixes to complex systems, adapting the process while maintaining documentation quality. Individual task files are stored in memory-bank/tasks/ with tasks.md serving as a reference document pointing to these files.

## üéØ SYSTEM PURPOSE

The Adaptive Memory Bank System creates persistent memory for AI assistants through structured documentation that scales based on task complexity. It addresses the fundamental limitation of LLMs forgetting context between interactions.

## üß† CORE PRINCIPLES

ALL PROJECTS WORK IN 4 PHASES
Conceptualization (Creative Phase)  
Design (Planning Phase) 
Implementation (Implementation Phase)
Continuous Improvement, making the Implementation Better (Continuous Improvement Phase)


1. **Documentation as Memory** - Documentation is mission-critical infrastructure
2. **Adaptive Process Scaling** - Process complexity matches task requirements
3. **Modular Task Management** - Individual task files in memory-bank/tasks/ with tasks.md as a reference document
4. **Strategic Content Organization** - Balance between core files and detailed examples
5. **Verification Steps** - Explicit checks prevent steps from being skipped
6. **Reference Triggers** - Force documentation consultation at critical points
7. **Processing Efficiency** - Optimized structure for LLM comprehension
8. **Structured Creative Thinking** - Creative phases as dedicated thinking spaces for complex problem-solving
9. **Consistent Archiving Process** - Standardized approach to archiving completed tasks

## üìè ADAPTIVE PROCESS LEVELS

### Level 1: Quick Bug Fix
- **Focus**: Simple errors, UI glitches, minor issues
- **Process**: Streamlined with minimal documentation
- **Task Updates**: 2-3 updates (start/end)
- **Memory Bank Impact**: Targeted updates to relevant files

### Level 2: Simple Enhancement
- **Focus**: Small features, minor improvements
- **Process**: Basic with essential documentation
- **Task Updates**: 4-6 updates at key milestones
- **Memory Bank Impact**: Updates to related files

### Level 3: Intermediate Feature
- **Focus**: Complete features, significant changes
- **Process**: Standard with full section tracking
- **Task Updates**: 8-12 updates at defined points
- **Memory Bank Impact**: Comprehensive updates to most files

### Level 4: Complex System
- **Focus**: Major systems, architectural changes
- **Process**: Full formal process with detailed checkpoints
- **Task Updates**: 15+ updates with formal verification
- **Memory Bank Impact**: Extensive updates to all files with cross-linking

## üé® CREATIVE PHASE HANDLING

For complex problem-solving, creative phases act as dedicated thinking spaces:

1. **Problem Breakdown** - Break complex problems into component parts for systematic analysis
2. **Option Exploration** - Consider multiple approaches with explicit pros/cons
3. **Systematic Verification** - Verify each option against specific requirements and constraints
4. **Checkpoint Process** - Use structured checkpoints to verify progress and compliance
5. **Comprehensive Verification** - Perform explicit verification before concluding creative work

Creative phase documentation scales with task complexity:
- **Level 1**: Minimal creative exploration markers
- **Level 2**: Basic creative phase structure
- **Level 3-4**: Full structured thinking with verification checkpoints

### Creative Phase Applications
- **Algorithm Design**: Analyze complexity requirements, alternative approaches, edge cases
- **UI/UX Design**: Explore layout options, information architecture, accessibility
- **Architecture Planning**: Design component boundaries, communication patterns, security models

See [creative-phase-examples.mdc](mdc:.cursor/rules/Extended%20Details/creative-phase-examples.mdc) for detailed examples.

## üìè RULE TYPES

### 1Ô∏è‚É£ Always-Applied Rules
```
---
description: 
globs: 
alwaysApply: true
---
```
- Applied to every command regardless of context
- Used for critical rules that must always be followed
- Kept concise to minimize context window usage
- Examples: main.mdc, verification-checklist-simplified.mdc

### 2Ô∏è‚É£ Auto-Attached Rules
```
---
description: 
globs: "**/memory-bank/**", "**/.cursor/rules"
alwaysApply: false
---
```
- Applied when working with matching file patterns
- Used for context-specific rules
- Can be more detailed since only loaded when relevant
- Examples: memory-bank.mdc, task-tracking.mdc

### 3Ô∏è‚É£ Agent-Requested Rules
```
---
description: CRITICAL: Contains mandatory examples. DO NOT assume patterns without consulting.
globs: "**/src/**"
alwaysApply: false
---
```
- Agent explicitly instructed to read these files
- Used for detailed examples and verbose content
- Helps manage context window by moving details out of main files
- Examples: workflow-examples.mdc, command-examples.mdc, creative-phase-examples.mdc

## üìÅ DIRECTORY STRUCTURE

```
.cursor/rules/
‚îú‚îÄ‚îÄ main.mdc                      # Master file with references
‚îú‚îÄ‚îÄ system-overview.mdc           # High-level system overview
‚îú‚îÄ‚îÄ Core Implementation/          # Core protocol files
‚îú‚îÄ‚îÄ Extended Details/             # Detailed examples
‚îî‚îÄ‚îÄ Templates/                    # File templates

Project Root:
‚îú‚îÄ‚îÄ memory-bank/                  # Documentation directory
‚îÇ   ‚îú‚îÄ‚îÄ projectbrief.md           # Requirements and goals
‚îÇ   ‚îú‚îÄ‚îÄ productContext.md         # Why this project exists
‚îÇ   ‚îú‚îÄ‚îÄ activeContext.md          # Current work focus
‚îÇ   ‚îú‚îÄ‚îÄ systemPatterns.md         # Architecture patterns
‚îÇ   ‚îú‚îÄ‚îÄ techContext.md            # Technologies used
‚îÇ   ‚îú‚îÄ‚îÄ progress.md               # Implementation status
‚îÇ   ‚îú‚îÄ‚îÄ tasks.md                  # Reference document pointing to individual task files
‚îÇ   ‚îú‚îÄ‚îÄ task_archiving.md         # Documentation of the task archiving process
‚îÇ   ‚îî‚îÄ‚îÄ tasks/                    # Directory containing individual task files
‚îú‚îÄ‚îÄ .cursorrules                  # Project-specific patterns (no task tracking)
‚îî‚îÄ‚îÄ docs/archive/
    ‚îî‚îÄ‚îÄ completed_tasks.md        # Archived completed tasks
```

## üîÑ REFERENCE TRIGGER PATTERN

Main files include explicit reference triggers:

```
‚ö†Ô∏è Before implementing any commands, I MUST read command-examples.mdc
```

This creates verification steps that force documentation consultation before proceeding.

## üìã ADAPTIVE IMPLEMENTATION WORKFLOW

### Level 0: Initial Design
1. **BASIC INITIALIZATION** - Check relevant files, state bug
2. **RAPID IMPLEMENTATION** - Make a base shell, verify solution
3. **QUICK DOCUMENTATION & ARCHIVING** - Create/update task file, add reference to tasks.md, and archive if completed

### Level 1: Quick Bug Fix
1. **STREAMLINED INITIALIZATION** - Check relevant files, state bug
2. **RAPID IMPLEMENTATION** - Fix issue, verify solution
3. **QUICK DOCUMENTATION & ARCHIVING** - Create/update task file, update reference in tasks.md, and archive if completed

### Level 2: Simple Enhancement
1. **BASIC INITIALIZATION** - Check relevant files, state enhancement
2. **SIMPLE DOCUMENTATION SETUP** - Create task file, add reference to tasks.md
3. **BASIC PLANNING** - Create 3-5 step plan in task file
4. **STANDARD IMPLEMENTATION** - Execute plan, update task file at key points
5. **BRIEF REFLECTION** - Note what worked and challenges
6. **ARCHIVING** - Archive completed task following task_archiving.md process

### Level 3: Intermediate Feature
Full 6-step workflow with standard documentation and proper archiving

### Level 4: Complex System
Full 6-step workflow with comprehensive documentation, verification, and formal archiving

## üîÑ TASK ARCHIVING PROCESS

When a task is completed:

1. **Update Task Status** - Mark as complete in the task file
2. **Update the Task File** - Add comprehensive entry to <task-name>.md
3. **Archive Details** - Add comprehensive entry to completed_tasks.md
4. **Move the Task File** - Move the task file to the archive directory
5. **Update Reference** - Update task reference in tasks.md
6. **Update Documentation** - Update related documentation files
7. **Commit Changes** - Commit all related changes in a single commit

## üîÑ TASK ESCALATION PROTOCOL

Process for handling tasks that prove more complex than initially categorized:

1. **Document Escalation Need**
2. **Get Approval for Escalation**
3. **Adjust Process to Higher Level**
4. **Continue with Enhanced Process**

## üí° BEST PRACTICES

- Keep core files concise (200-300 lines maximum)
- Move detailed examples to extended files
- Add reference triggers for detailed documentation
- Use appropriate rule types for each file's purpose
- Document reference relationships between files
- Create individual task files with comprehensive information
- Use tasks.md as a reference document pointing to individual task files
- Store task files with a consistent naming convention
- Follow the established archiving process for completed tasks
- Match process complexity to task requirements
- Use creative phases as structured thinking spaces for complex problems
- Perform systematic verification before concluding creative work
- Return to task tracking after creative phases

## üìä COMPLEXITY DETERMINATION GUIDELINES

To determine the appropriate complexity level:

### Level 0 Indicators
- Contains words like "design", "create", "analyze", "plan"
- Affects entire application
- Requires extensive planning

### Level 1 Indicators
- Contains words like "fix", "broken", "not working"
- Affects a single component
- Restores existing functionality
- Can be completed very quickly

### Level 2 Indicators
- Contains words like "add", "improve", "update"
- Affects a single subsystem
- Self-contained enhancement
- Can be completed relatively quickly

### Level 3 Indicators
- Contains words like "implement", "create", "develop"
- Affects multiple components
- Significant new functionality
- Requires substantial planning

### Level 4 Indicators
- Contains words like "system", "architecture", "redesign"
- Affects entire application or multiple subsystems
- Major architectural changes
- Requires extensive planning and coordination
